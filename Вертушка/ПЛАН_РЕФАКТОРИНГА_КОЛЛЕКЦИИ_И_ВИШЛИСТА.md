# План рефакторинга: Коллекция и Вишлист

## 📋 Цель
Исправить логику работы коллекции и вишлиста, устранив конфликты и сделав приложение предсказуемым по примеру Discogs, Letterboxd и Goodreads.

---

## 🔴 Текущие проблемы

### Проблема #1: Одна пластинка может быть одновременно в двух местах
```
Ситуация:
- record_id=123 добавлен в collection_items
- record_id=123 добавлен в wishlist_items
- ❌ Конфликт: пластинка и в "Моё" и в "Хочу" одновременно
```

### Проблема #2: Приоритизация на фронтенде
```typescript
// record/[id].tsx:93-100
const status = {
  inCollection: !!collectionItem,
  inWishlist: !collectionItem && !!wishlistItem, // Игнорирует вишлист если есть в коллекции
}
```
**Результат**: в разделе "Коллекция" показывается интерфейс вишлиста из-за этой костыльной логики.

### Проблема #3: Кнопки работают непредсказуемо
- Кнопка "Хочу" не нажимается при добавлении из поиска
- Ошибки при попытке добавить в вишлист из коллекции
- "Американские горки" - чинишь одно, ломается другое

---

## 🎯 Принцип решения (как у Discogs)

### ✅ ОДИН СТАТУС = ОДНО МЕСТО

```
Пластинка может быть только в ОДНОМ состоянии:
├─ Не добавлена (нигде нет)
├─ В вишлисте (только в wishlist_items)
└─ В коллекции (только в collection_items, может быть несколько копий)
```

### Правила:
1. **Автоматическое удаление из вишлиста** при добавлении в коллекцию
2. **Запрет добавления в вишлист** если уже есть в коллекции (хотя бы одна копия)
3. **Дубликаты разрешены ТОЛЬКО в коллекции** (разные копии одной пластинки)
4. **Нет переноса из коллекции в вишлист** (только удаление всех копий + ручное добавление в вишлист)

---

## 🛠 Технический план изменений

## 1️⃣ BACKEND: Валидация и автоматическое удаление

### 1.1. Добавить constraint на уровне БД (опционально)

```python
# Миграция Alembic
# Файл: alembic/versions/XXXX_unique_wishlist_record.py

def upgrade():
    # Добавляем UNIQUE constraint на wishlist_items
    # Один пользователь не может добавить одну пластинку в вишлист дважды
    op.create_unique_constraint(
        'uq_wishlist_record',
        'wishlist_items',
        ['wishlist_id', 'record_id']
    )
```

**Зачем**: Гарантирует на уровне БД, что в вишлисте не будет дубликатов одной пластинки.

---

### 1.2. Изменить `POST /collections/{collection_id}/items`

**Файл**: `Backend/app/api/collections.py:244`

**Текущий код**:
```python
# Просто добавляет, даже если уже в вишлисте
item = CollectionItem(
    collection_id=collection_id,
    record_id=record.id,
    ...
)
db.add(item)
await db.commit()
```

**Новый код**:
```python
@router.post("/{collection_id}/items", ...)
async def add_record_to_collection(...):
    from app.models.wishlist import Wishlist, WishlistItem

    # ... существующий код получения collection и record ...

    # ✅ НОВОЕ: Проверяем, есть ли эта пластинка в вишлисте текущего пользователя
    wishlist_item_query = await db.execute(
        select(WishlistItem)
        .join(Wishlist)
        .where(
            Wishlist.user_id == current_user.id,
            WishlistItem.record_id == record.id
        )
    )
    wishlist_item = wishlist_item_query.scalar_one_or_none()

    # ✅ НОВОЕ: Если в вишлисте - автоматически удаляем
    if wishlist_item:
        print(f"🔄 add_record_to_collection: removing from wishlist, item_id={wishlist_item.id}")
        await db.delete(wishlist_item)

    # Добавляем в коллекцию (дубликаты разрешены)
    item = CollectionItem(
        collection_id=collection_id,
        record_id=record.id,
        condition=data.condition,
        sleeve_condition=data.sleeve_condition,
        notes=data.notes
    )
    db.add(item)
    await db.commit()
    await db.refresh(item)

    return CollectionItemResponse(...)
```

**Что это даёт**:
- При добавлении в коллекцию из поиска - просто добавляет
- При добавлении в коллекцию, если пластинка была в вишлисте - **атомарно переносит** (удаляет из вишлиста, добавляет в коллекцию)
- Можно добавлять несколько копий одной пластинки в коллекцию

---

### 1.3. Изменить `POST /wishlists/items`

**Файл**: `Backend/app/api/wishlists.py:88`

**Текущий код**:
```python
# Проверяет только дубликаты в вишлисте
result = await db.execute(
    select(WishlistItem)
    .where(
        WishlistItem.wishlist_id == wishlist.id,
        WishlistItem.record_id == record.id
    )
)
if result.scalar_one_or_none():
    raise HTTPException(400, "Пластинка уже в вишлисте")
```

**Новый код**:
```python
@router.post("/items", ...)
async def add_to_wishlist(...):
    from app.models.collection import Collection, CollectionItem

    # ... существующий код получения wishlist и record ...

    # ✅ НОВОЕ: Проверяем, есть ли эта пластинка в коллекции (хотя бы одна копия)
    collection_item_query = await db.execute(
        select(CollectionItem)
        .join(Collection)
        .where(
            Collection.user_id == current_user.id,
            CollectionItem.record_id == record.id
        )
    )
    if collection_item_query.scalar_one_or_none():
        print(f"❌ add_to_wishlist: record already in collection")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Пластинка уже в вашей коллекции"
        )

    # Проверяем дубликаты в вишлисте (существующая логика)
    result = await db.execute(
        select(WishlistItem)
        .where(
            WishlistItem.wishlist_id == wishlist.id,
            WishlistItem.record_id == record.id
        )
    )
    if result.scalar_one_or_none():
        print(f"❌ add_to_wishlist: already in wishlist")
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Пластинка уже в вишлисте"
        )

    # Добавляем в вишлист
    item = WishlistItem(
        wishlist_id=wishlist.id,
        record_id=record.id,
        priority=data.priority,
        notes=data.notes
    )
    db.add(item)
    await db.commit()
    await db.refresh(item)

    return WishlistItemResponse(...)
```

**Что это даёт**:
- ❌ Нельзя добавить в вишлист, если пластинка уже в коллекции
- ⚠️ Понятная ошибка с объяснением для пользователя

---

### 1.4. Endpoint `POST /wishlists/items/{item_id}/move-to-collection` - ОСТАВИТЬ КАК ЕСТЬ ✅

**Файл**: `Backend/app/api/wishlists.py:456`

Этот endpoint уже работает правильно:
```python
# 1. Создаёт элемент в коллекции
collection_item = CollectionItem(...)
db.add(collection_item)

# 2. Удаляет из вишлиста
await db.delete(wishlist_item)

# 3. Атомарный commit
await db.commit()
```

**Ничего менять не нужно!** Это уже правильная реализация.

---

### 1.5. УБРАТЬ endpoint для переноса из коллекции в вишлист

**Действие**: Не создаём endpoint `move-to-wishlist`.

**Почему**:
- Discogs не поддерживает автоматический перенос Collection → Wantlist
- Если пользователь хочет пластинку обратно в вишлист:
  1. Удалить ВСЕ копии из коллекции
  2. Добавить в вишлист заново

**Что убрать из фронтенда**: функции `moveToWishlist` в store и UI

---

## 2️⃣ FRONTEND: Упростить логику и UI

### 2.1. Обновить типы

**Файл**: `Mobile/lib/types.ts`

```typescript
// Добавить новый тип для статуса пластинки
export type RecordStatus =
  | 'not_added'      // Нигде не добавлена
  | 'in_collection'  // В коллекции (может быть несколько копий)
  | 'in_wishlist';   // В вишлисте
```

---

### 2.2. Упростить `useCollectionStore`

**Файл**: `Mobile/lib/store.ts:330`

**Удалить функцию**:
```typescript
// ❌ УДАЛИТЬ moveToWishlist - Discogs не поддерживает этот сценарий
moveToWishlist: async (itemId) => { ... }
```

**Обновить `addToCollection`**:
```typescript
addToCollection: async (discogsId) => {
  let { defaultCollection, collections, fetchCollectionItems, fetchWishlistItems } = get();

  // ... существующая логика создания коллекции если нет ...

  console.log('🔵 addToCollection: adding to collection', defaultCollection.id);
  await api.addToCollection(defaultCollection.id, discogsId);

  // ✅ ВАЖНО: обновляем ОБА списка, т.к. сервер мог удалить из вишлиста
  await Promise.all([
    fetchCollectionItems(),
    fetchWishlistItems()
  ]);

  console.log('✅ addToCollection: success');
},
```

---

### 2.3. Упростить логику определения статуса

**Файл**: `Mobile/app/record/[id].tsx:67`

**Текущий код** (убрать приоритизацию):
```typescript
const getRecordStatus = () => {
  // ... сложная логика с приоритетами ...
  const status = {
    inCollection: !!collectionItem,
    inWishlist: !collectionItem && !!wishlistItem, // ❌ Костыль!
    collectionItemId: collectionItem?.id || null,
    wishlistItemId: wishlistItem?.id || null,
  };
  return status;
}
```

**Новый код**:
```typescript
const getRecordStatus = (): {
  status: RecordStatus;
  copiesCount: number;
  collectionItemId: string | null;
  wishlistItemId: string | null;
} => {
  if (!record) {
    return {
      status: 'not_added',
      copiesCount: 0,
      collectionItemId: null,
      wishlistItemId: null
    };
  }

  const discogsId = record.discogs_id;
  const recordId = record.id;

  // Ищем все копии в коллекции
  const collectionCopies = collectionItems.filter(
    (item) => item.record.discogs_id === discogsId || item.record.id === recordId
  );

  // Ищем в вишлисте
  const wishlistItem = wishlistItems.find(
    (item) => item.record.discogs_id === discogsId || item.record.id === recordId
  );

  // ✅ ГАРАНТИЯ: сервер обеспечивает, что пластинка НЕ может быть в обоих местах
  if (collectionCopies.length > 0) {
    return {
      status: 'in_collection',
      copiesCount: collectionCopies.length,
      collectionItemId: collectionCopies[0].id,
      wishlistItemId: null,
    };
  }

  if (wishlistItem) {
    return {
      status: 'in_wishlist',
      copiesCount: 0,
      collectionItemId: null,
      wishlistItemId: wishlistItem.id,
    };
  }

  return {
    status: 'not_added',
    copiesCount: 0,
    collectionItemId: null,
    wishlistItemId: null,
  };
};
```

---

### 2.4. Обновить обработчики кнопок

**Файл**: `Mobile/app/record/[id].tsx:129`

**Обновить `handleAddToCollection`**:
```typescript
const handleAddToCollection = async () => {
  if (!record) return;

  const recordStatus = getRecordStatus();

  // Если в вишлисте - используем атомарный перенос
  if (recordStatus.status === 'in_wishlist' && recordStatus.wishlistItemId) {
    try {
      await moveToCollection(recordStatus.wishlistItemId);
      // ✅ Обновляем ОБА списка
      await Promise.all([
        fetchCollectionItems(),
        fetchWishlistItems(),
      ]);
      Alert.alert('Готово!', 'Пластинка перенесена в коллекцию');
    } catch (error: any) {
      const message = error?.response?.data?.detail || 'Не удалось перенести в коллекцию';
      Alert.alert('Ошибка', message);
    }
    return;
  }

  // Иначе просто добавляем в коллекцию
  const discogsId = record.discogs_id || id;
  if (!discogsId) {
    Alert.alert('Ошибка', 'Не найден идентификатор пластинки');
    return;
  }

  try {
    await addToCollection(discogsId);
    // ✅ addToCollection уже обновляет оба списка
    Alert.alert('Готово!', 'Пластинка добавлена в коллекцию');
  } catch (error: any) {
    const message = error?.response?.data?.detail || 'Не удалось добавить в коллекцию';
    Alert.alert('Ошибка', message);
  }
};
```

**Обновить `handleAddToWishlist`**:
```typescript
const handleAddToWishlist = async () => {
  if (!record) return;

  const discogsId = record.discogs_id || id;
  if (!discogsId) {
    Alert.alert('Ошибка', 'Не найден идентификатор пластинки');
    return;
  }

  try {
    await addToWishlist(discogsId);
    await fetchWishlistItems();
    Alert.alert('Готово!', 'Пластинка добавлена в список желаний');
  } catch (error: any) {
    // ✅ Сервер вернёт понятную ошибку "Пластинка уже в коллекции"
    const message = error?.response?.data?.detail || 'Не удалось добавить в список желаний';
    Alert.alert('Ошибка', message);
  }
};
```

**УДАЛИТЬ `handleMoveToWishlist`**:
```typescript
// ❌ УДАЛИТЬ - Discogs не поддерживает этот сценарий
// const handleMoveToWishlist = async () => { ... }
```

---

### 2.5. Обновить UI кнопок

**Файл**: `Mobile/app/record/[id].tsx:496`

**Текущий код**:
```typescript
// Сложная логика с if (status.inCollection) и т.д.
```

**Новый код**:
```typescript
{/* Кнопки действий */}
{(() => {
  const recordStatus = getRecordStatus();

  // ========== СТАТУС: В КОЛЛЕКЦИИ ==========
  if (recordStatus.status === 'in_collection') {
    return (
      <View style={[styles.actionsContainer, { paddingBottom: insets.bottom + Spacing.md }]}>
        <View style={styles.addedButtonContainer}>
          <View style={styles.addedButton}>
            <Ionicons name="checkmark-circle" size={20} color={Colors.textSecondary} />
            <Text style={styles.addedButtonText}>
              {recordStatus.copiesCount > 1
                ? `Добавлено (${recordStatus.copiesCount})`
                : 'Добавлено'
              }
            </Text>
          </View>
          <TouchableOpacity
            style={styles.moreButton}
            onPress={() => setShowActionSheet(true)}
          >
            <Ionicons name="ellipsis-vertical" size={24} color={Colors.background} />
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  // ========== СТАТУС: В ВИШЛИСТЕ ==========
  if (recordStatus.status === 'in_wishlist') {
    return (
      <View style={[styles.actionsContainer, { paddingBottom: insets.bottom + Spacing.md }]}>
        <Button
          title="В коллекцию"
          onPress={handleAddToCollection}  {/* Атомарный перенос */}
          style={styles.actionButton}
        />
        <TouchableOpacity
          style={[styles.actionButton, styles.removeButton]}
          onPress={handleRemoveFromWishlist}
        >
          <Text style={styles.removeButtonText}>Удалить</Text>
        </TouchableOpacity>
      </View>
    );
  }

  // ========== СТАТУС: НЕ ДОБАВЛЕНА ==========
  return (
    <View style={[styles.actionsContainer, { paddingBottom: insets.bottom + Spacing.md }]}>
      <Button
        title="В коллекцию"
        onPress={handleAddToCollection}
        style={styles.actionButton}
      />
      <Button
        title="Хочу"
        onPress={handleAddToWishlist}
        variant="outline"
        style={styles.actionButton}
      />
    </View>
  );
})()}
```

---

### 2.6. Обновить Action Sheet меню

**Файл**: `Mobile/app/record/[id].tsx:320`

**Новый код**:
```typescript
const getActionSheetActions = (): ActionSheetAction[] => {
  const recordStatus = getRecordStatus();
  const actions: ActionSheetAction[] = [];

  if (recordStatus.status === 'in_collection') {
    // Добавить копию (всегда доступно)
    actions.push({
      label: 'Добавить копию в коллекцию',
      icon: 'copy-outline',
      onPress: handleAddCopyToCollection,
    });

    // ❌ УБРАЛИ "Отправить в вишлист" - как в Discogs
    // Пользователь должен удалить все копии и добавить в вишлист вручную

    // Удалить эту копию
    actions.push({
      label: 'Удалить',
      icon: 'trash-outline',
      onPress: handleRemoveFromCollection,
      destructive: true,
    });
  }

  return actions;
};
```

---

### 2.7. Обновить экран коллекции

**Файл**: `Mobile/app/(tabs)/collection.tsx:247`

**УДАЛИТЬ функцию**:
```typescript
// ❌ УДАЛИТЬ handleBulkMoveToWishlist
// const handleBulkMoveToWishlist = async () => { ... }
```

**УДАЛИТЬ из UI**:
```typescript
// В selectionFooter:
// ❌ УДАЛИТЬ кнопку "В хочу" для элементов коллекции

{activeTab === 'wishlist' ? (
  <TouchableOpacity
    style={styles.footerButton}
    onPress={handleBulkMoveToCollection}
    disabled={selectedItems.size === 0}
  >
    {/* ... В коллекцию ... */}
  </TouchableOpacity>
) : (
  // ❌ УДАЛИТЬ эту ветку - больше нет переноса из коллекции в вишлист
  null
)}

<TouchableOpacity
  style={[styles.footerButton, styles.footerButtonDelete]}
  onPress={handleBulkDelete}
  disabled={selectedItems.size === 0}
>
  {/* Удалить - оставляем */}
</TouchableOpacity>
```

---

## 3️⃣ ТЕСТИРОВАНИЕ

### Сценарии для проверки:

#### ✅ Сценарий 1: Добавление из поиска
```
1. Найти пластинку в поиске
2. Нажать "Хочу" → добавилась в вишлист ✅
3. Открыть эту же пластинку
4. Нажать "В коллекцию" → удалилась из вишлиста, добавилась в коллекцию ✅
5. Проверить раздел "Хочу" → пластинки там нет ✅
6. Проверить раздел "Моё" → пластинка там есть ✅
```

#### ✅ Сценарий 2: Запрет добавления в вишлист
```
1. Добавить пластинку в коллекцию
2. Попробовать добавить её в вишлист
3. Ожидается: ошибка "Пластинка уже в вашей коллекции" ✅
```

#### ✅ Сценарий 3: Дубликаты в коллекции
```
1. Добавить пластинку в коллекцию
2. Открыть меню [⋮]
3. Нажать "Добавить копию"
4. Проверить: в коллекции 2 копии ✅
5. Кнопка показывает "Добавлено (2)" ✅
```

#### ✅ Сценарий 4: Атомарный перенос из вишлиста
```
1. Добавить пластинку в вишлист
2. Открыть пластинку
3. Нажать "В коллекцию"
4. Проверить: пластинка удалена из вишлиста, добавлена в коллекцию ✅
5. Кнопки изменились на "Добавлено" + меню ✅
```

#### ✅ Сценарий 5: Удаление из коллекции
```
1. Добавить пластинку в коллекцию
2. Удалить её из коллекции
3. Попробовать добавить в вишлист
4. Ожидается: успешно добавляется ✅
```

---

## 4️⃣ ФИНАЛЬНАЯ АРХИТЕКТУРА

### Правила (жёсткие гарантии):

```
┌─────────────────────────────────────────────────────────┐
│ ПРАВИЛО №1: Один статус в один момент                   │
│ ─────────────────────────────────────────────────────── │
│ Пластинка может быть ТОЛЬКО в одном месте:              │
│   • Не добавлена                                        │
│   • В вишлисте (только ОДНА запись)                     │
│   • В коллекции (может быть НЕСКОЛЬКО копий)            │
│                                                         │
│ ❌ НЕВОЗМОЖНО: быть одновременно в вишлисте и коллекции │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ ПРАВИЛО №2: Автоматическое удаление                     │
│ ─────────────────────────────────────────────────────── │
│ При добавлении в коллекцию:                             │
│   1. Проверить вишлист                                  │
│   2. Если найдена → автоматически удалить               │
│   3. Добавить в коллекцию                               │
│   4. Commit (атомарная транзакция)                      │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ ПРАВИЛО №3: Запрет обратного добавления                 │
│ ─────────────────────────────────────────────────────── │
│ При попытке добавить в вишлист:                         │
│   1. Проверить коллекцию                                │
│   2. Если найдена хотя бы ОДНА копия → ошибка           │
│   3. Иначе → добавить в вишлист                         │
└─────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────┐
│ ПРАВИЛО №4: Дубликаты только в коллекции                │
│ ─────────────────────────────────────────────────────── │
│ В коллекции:                                            │
│   ✅ Можно добавить несколько копий одной пластинки     │
│   ✅ Каждая копия = отдельный CollectionItem с UUID     │
│                                                         │
│ В вишлисте:                                             │
│   ❌ Только ОДНА запись на пластинку                    │
│   ❌ UNIQUE(wishlist_id, record_id)                     │
└─────────────────────────────────────────────────────────┘
```

---

## 5️⃣ ОБОСНОВАНИЕ РЕШЕНИЯ

### Почему именно так?

#### ✅ **По примеру Discogs** (эталон для винила)
- Автоматическое удаление из Wantlist при добавлении в Collection
- Нет переноса из Collection в Wantlist
- Поддержка дубликатов в коллекции

#### ✅ **По примеру Letterboxd** (для фильмов)
- Автоматическое перемещение между статусами
- Один статус в один момент

#### ✅ **По примеру Goodreads** (для книг)
- Взаимоисключающие статусы
- Автоматическая замена при изменении статуса

### Преимущества:

1. **Нет конфликтов** - невозможно создать противоречивое состояние
2. **Простой код** - меньше условий, меньше багов
3. **Предсказуемость** - пользователь понимает, что происходит
4. **Производительность** - меньше проверок на фронтенде
5. **Поддержка дубликатов** - важно для коллекционеров (разные прессовки, состояния)

---

## 6️⃣ ПОРЯДОК ВНЕДРЕНИЯ

### Шаг 1: Backend (1-2 часа)
1. Обновить `POST /collections/{id}/items` - добавить автоудаление из вишлиста
2. Обновить `POST /wishlists/items` - добавить проверку коллекции
3. Протестировать API через Swagger/Postman

### Шаг 2: Frontend (2-3 часа)
1. Обновить типы (`RecordStatus`)
2. Упростить `getRecordStatus()` (убрать приоритизацию)
3. Удалить `moveToWishlist` из store
4. Обновить UI кнопок на странице пластинки
5. Убрать кнопку "В вишлист" из меню коллекции
6. Обновить экран коллекции (убрать bulk move to wishlist)

### Шаг 3: Тестирование (1 час)
1. Пройти все сценарии из раздела "Тестирование"
2. Проверить edge cases (дубликаты, переходы между статусами)

### Шаг 4: Миграция БД (опционально, 30 мин)
1. Создать миграцию для UNIQUE constraint на wishlist_items
2. Очистить конфликтующие данные перед применением constraint
3. Применить миграцию

---

## 📚 Референсы

- [Discogs: Add To Wantlist Feature](https://support.discogs.com/hc/en-us/articles/360014045654-Add-To-Wantlist-Use-The-Wantlist-Feature)
- [Discogs Forum: Multiple copies of same record](https://www.discogs.com/forum/thread/228330)
- [Letterboxd FAQ](https://letterboxd.com/about/faq/)
- [Goodreads: Move books between shelves](https://help.goodreads.com/s/question/0D51H00005OR60BSAT)

---

**Дата создания**: 2026-01-20
**Статус**: Готов к внедрению ✅
