# Полное руководство по Cursor AI

## Содержание
1. [Основы работы с Cursor AI](#основы)
2. [Команды с символом `/` (Slash Commands)](#slash-commands)
3. [Использование символа `@` для контекста](#символ-для-контекста)
4. [Система правил (Rules)](#система-правил)
5. [Лучшие практики](#лучшие-практики)
6. [Примеры для проекта Вертушка](#примеры-для-вертушки)

---

## Основы работы с Cursor AI {#основы}

Cursor AI — это AI-ассистент для программирования, который помогает писать код, редактировать файлы и автоматизировать задачи разработки.

### Основные режимы работы:

- **Agent Mode (Composer)** — автономный режим, где AI может выполнять множественные действия: читать файлы, редактировать код, запускать команды терминала
- **Inline Edit (Cmd+K)** — точечное редактирование выделенного кода
- **Chat Mode** — обычный чат для вопросов и обсуждений
- **Ask Mode** — режим вопрос-ответ без автоматических действий

---

## Команды с символом `/` (Slash Commands) {#slash-commands}

Slash-команды позволяют быстро выполнять действия без длинных описаний.

### Что появляется при вводе `/`:

Когда вы вводите `/` в поле ввода чата, появляется меню с двумя разделами:

#### 1. **Commands** (Ваши кастомные команды)
Здесь отображаются команды, которые вы создали сами в папке `.cursor/commands/`.

**Пример:**
- `/commit` — ваша кастомная команда для коммита изменений

#### 2. **Actions** (Встроенные действия Cursor)
Стандартные действия, доступные в Cursor:

- **Summarize** — суммировать выделенный код или контекст
- **Agent Review** — запустить агента для ревью кода
- **+ Create Command** — создать новую кастомную команду

### Как создавать свои slash-команды:

#### Способ 1: Через интерфейс
1. Введите `/` в чате
2. Выберите **"+ Create Command"**
3. Следуйте инструкциям

#### Способ 2: Через файлы
Создайте файл `.md` в папке `.cursor/commands/`:

**Файл**: `.cursor/commands/scan-vinyl.md`
```markdown
Сканирует штрихкод пластинки и ищет её в Discogs API.
Затем предлагает добавить в коллекцию или wishlist.
```

После создания файла команда `/scan-vinyl` появится в меню при вводе `/`.

### Примеры кастомных команд для проекта Вертушка:

**`.cursor/commands/scan-barcode.md`**
```markdown
Сканирует штрихкод пластинки, ищет в локальной БД, затем в Discogs API.
Показывает результаты и позволяет добавить в коллекцию.
```

**`.cursor/commands/add-to-collection.md`**
```markdown
Добавляет пластинку в коллекцию пользователя.
Требует discogs_id и опционально condition, price, location.
```

**`.cursor/commands/find-stores.md`**
```markdown
Находит виниловые магазины рядом с текущей геолокацией пользователя.
Показывает расстояние, часы работы и наличие пластинок.
```

---

## Использование символа `@` для контекста {#символ-для-контекста}

Символ `@` позволяет явно указывать AI, к каким файлам, правилам или ресурсам обращаться.

### Основные типы `@` ссылок:

#### 1. Ссылки на файлы
```
@filename.ts          - Подключить конкретный файл
@backend/api/records.py - Подключить файл по пути
@models/record.py     - Подключить файл из папки models
```

#### 2. Ссылки на правила
```
@rules                - Применить все правила проекта
@naming-conventions   - Применить конкретное правило
@vinyl-record-rules   - Правило для работы с пластинками
```

#### 3. Ссылки на код и документацию
```
@codebase             - Поиск по всему кодовому базе
@web                  - Поиск в интернете
@documentation        - Документация проекта
```

#### 4. Ссылки на папки
```
@components/          - Все файлы из папки components
@backend/app/api/    - Все API файлы
```

### Примеры использования:

**Пример 1: Редактирование функции с контекстом**
```
Измени функцию scanRecord в @backend/app/api/records.py, 
чтобы она также проверяла локальную БД перед запросом к Discogs
```

**Пример 2: Применение правил**
```
@vinyl-record-rules @backend/app/models/record.py
Добавь поле для хранения состояния пластинки (mint, near mint, etc.)
```

**Пример 3: Поиск по кодовой базе**
```
@codebase Как реализовано сканирование штрихкодов в мобильном приложении?
```

---

## Система правил (Rules) {#система-правил}

Правила (Rules) — это постоянные инструкции для AI, которые определяют, как он должен работать с вашим проектом.

### Типы правил:

#### 1. **Project Rules** (`.cursor/rules/*.mdc`)
- Хранятся в папке `.cursor/rules/` проекта
- Версионируются вместе с кодом (в git)
- Применяются только к текущему проекту
- Формат: файлы с расширением `.mdc`

#### 2. **User Rules** (Глобальные правила)
- Настраиваются в Cursor → Settings → Rules
- Применяются ко всем проектам пользователя
- Подходят для личных предпочтений (стиль кода, язык ответов)

#### 3. **Legacy `.cursorrules`**
- Старый формат, всё ещё поддерживается
- Рекомендуется мигрировать на `.cursor/rules/*.mdc`

### Структура файла правила:

```markdown
---
description: Краткое описание правила
globs:
  - "**/*.py"
  - "backend/**/*.ts"
alwaysApply: false
---

# Название правила

## Описание
Подробное описание того, что это правило делает и когда применяется.

## Правила

- Используй async/await вместо callbacks
- Всегда обрабатывай ошибки с try/except
- Используй type hints для всех функций

## Примеры

```python
# ✅ Правильно
async def get_record(id: str) -> Record:
    try:
        return await db.get(id)
    except Exception as e:
        logger.error(f"Error: {e}")
        raise

# ❌ Неправильно
def get_record(id):
    return db.get(id)
```

## Ссылки на файлы

@backend/app/models/record.py
@backend/app/api/records.py
```

### Метаданные правил:

- **`description`** (обязательно) — краткое описание правила
- **`globs`** (опционально) — шаблоны файлов, к которым применяется правило
  - `"**/*.py"` — все Python файлы
  - `"backend/**/*.ts"` — все TypeScript файлы в backend
  - `"**/*.{ts,tsx}"` — все TypeScript и TSX файлы
- **`alwaysApply`** (опционально) — если `true`, правило всегда загружается

### Типы применения правил:

1. **Always** (`alwaysApply: true`) — всегда включается в контекст
2. **Auto Attached** — автоматически подключается при редактировании файлов по шаблону `globs`
3. **Agent Requested** — AI сам решает, применять ли правило (нужно хорошее описание)
4. **Manual** — применяется только при явном указании `@ruleName`

### Где создавать правила:

1. **В проекте**: `.cursor/rules/your-rule.mdc`
2. **В настройках Cursor**: Settings → Rules → User Rules

---

## Лучшие практики {#лучшие-практики}

### 1. Структура правил

✅ **Хорошо:**
- Краткие правила (< 500 строк)
- Одно правило = одна тема
- Конкретные примеры "do this / avoid that"
- Ссылки на реальные файлы проекта

❌ **Плохо:**
- Огромные правила на 2000+ строк
- Смешивание разных тем в одном правиле
- Абстрактные инструкции без примеров

### 2. Организация правил

Разделяйте правила по категориям:

```
.cursor/rules/
├── architecture.mdc      # Архитектурные решения
├── coding-style.mdc      # Стиль кода
├── api-conventions.mdc   # Конвенции API
├── database.mdc          # Работа с БД
├── testing.mdc          # Тестирование
└── vinyl-specific.mdc   # Специфичные для проекта
```

### 3. Использование `@` ссылок

✅ **Хорошо:**
```
@backend/app/models/record.py
Добавь валидацию для поля year
```

❌ **Плохо:**
```
Добавь валидацию для поля year в модели Record
```
(без указания файла AI может не найти правильный файл)

### 4. Slash-команды

Создавайте команды для частых задач:

```markdown
---
description: Команды для работы с пластинками
---

## Slash Commands

/scan-barcode <code>
-> Сканировать штрихкод и найти пластинку в Discogs

/add-record <discogs_id>
-> Добавить пластинку в коллекцию по Discogs ID

/search-records <query>
-> Поиск пластинок по запросу
```

### 5. Версионирование правил

- Храните правила в git
- Комментируйте изменения в правилах
- Используйте понятные названия файлов

---

## Примеры для проекта Вертушка {#примеры-для-вертушки}

### Пример 1: Правило для работы с пластинками

**Файл**: `.cursor/rules/vinyl-records.mdc`

```markdown
---
description: Правила работы с данными виниловых пластинок
globs:
  - "**/models/record.py"
  - "**/api/records.py"
  - "**/schemas/record.py"
alwaysApply: false
---

# Работа с виниловыми пластинками

## Структура данных

Все записи о пластинках должны содержать:
- `discogs_id` — ID в Discogs (может быть null для ручного ввода)
- `title` — название альбома (обязательно)
- `artist` — исполнитель (обязательно)
- `year` — год выпуска (опционально)
- `label` — лейбл (опционально)
- `barcode` — штрихкод (опционально, но рекомендуется)

## Интеграция с Discogs

- Всегда сначала проверяй локальную БД перед запросом к Discogs API
- Кэшируй результаты запросов к Discogs
- Обрабатывай ошибки API gracefully (не падай, если Discogs недоступен)

## Примеры

@backend/app/models/record.py
@backend/app/services/discogs.py
```

### Пример 2: Правило для сканирования

**Файл**: `.cursor/rules/scanning.mdc`

```markdown
---
description: Правила для функций сканирования пластинок
globs:
  - "**/api/records.py"
  - "Mobile/**/*scan*.tsx"
alwaysApply: false
---

# Сканирование пластинок

## Штрихкоды

- Поддерживаемые форматы: EAN-13, EAN-8, UPC-A, UPC-E
- После сканирования всегда проверяй локальную БД
- Если не найдено локально — запрос к Discogs API
- Показывай индикатор загрузки во время поиска

## Распознавание обложек (будущая функция)

- Используй высокое разрешение для фотографий
- Поддерживай форматы: JPG, PNG
- Обрабатывай плохое освещение и искажения
- После распознавания — поиск в Discogs по артисту и названию

## Примеры

@Mobile/app/(tabs)/index.tsx
@backend/app/api/records.py
```

### Пример 3: Правило для API

**Файл**: `.cursor/rules/api-conventions.mdc`

```markdown
---
description: Конвенции для API endpoints
globs:
  - "**/api/*.py"
alwaysApply: true
---

# API Конвенции

## Структура endpoints

- Используй FastAPI роутеры
- Все endpoints требуют авторизации, кроме публичных (явно помечай)
- Используй Pydantic схемы для валидации
- Возвращай стандартные HTTP статус коды

## Обработка ошибок

- Используй HTTPException для ошибок
- Всегда логируй ошибки
- Не возвращай детали ошибок клиенту в продакшене

## Примеры

```python
# ✅ Правильно
@router.get("/records/{record_id}")
async def get_record(
    record_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    try:
        record = await db.get(Record, record_id)
        if not record:
            raise HTTPException(status_code=404, detail="Record not found")
        return record
    except Exception as e:
        logger.error(f"Error getting record {record_id}: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

@backend/app/api/records.py
```

### Пример 4: Использование в чате

**Пример запроса с использованием правил:**

```
@vinyl-records @backend/app/api/records.py
Добавь endpoint для поиска пластинок по артисту и году выпуска.
Используй существующую схему RecordSearchResponse.
```

**Пример с несколькими файлами:**

```
@backend/app/models/record.py @backend/app/schemas/record.py
Добавь поле "condition" (состояние пластинки) в модель и схему.
Возможные значения: mint, near_mint, very_good, good, fair, poor.
```

---

## Полезные советы

1. **Начните с малого** — создайте 2-3 базовых правила, затем расширяйте
2. **Тестируйте правила** — проверяйте, что AI правильно их применяет
3. **Обновляйте правила** — по мере развития проекта правила могут устаревать
4. **Используйте примеры** — конкретные примеры помогают AI лучше понять намерения
5. **Ссылайтесь на файлы** — используйте `@` для подключения контекста

---

## Дополнительные ресурсы

- [Официальная документация Cursor Rules](https://docs.cursor.com/en/context/rules)
- [Документация по @ символам](https://docs.cursor.com/en/context/@-symbols)
- [Slash Commands Reference](https://docs.cursor.com/en/cli/reference/slash-commands)

---

**Последнее обновление**: 2024
